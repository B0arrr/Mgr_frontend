// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'scheduler_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$SchedulerEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initScheduler,
    required TResult Function(UserSchedule userSchedule) addSchedule,
    required TResult Function(UserSchedule userSchedule) removeSchedule,
    required TResult Function(
            UserSchedule oldUserSchedule, UserSchedule newUserSchedule)
        updateSchedule,
    required TResult Function(List<User> users, DateTime start, DateTime end)
        generateSchedule,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initScheduler,
    TResult? Function(UserSchedule userSchedule)? addSchedule,
    TResult? Function(UserSchedule userSchedule)? removeSchedule,
    TResult? Function(
            UserSchedule oldUserSchedule, UserSchedule newUserSchedule)?
        updateSchedule,
    TResult? Function(List<User> users, DateTime start, DateTime end)?
        generateSchedule,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initScheduler,
    TResult Function(UserSchedule userSchedule)? addSchedule,
    TResult Function(UserSchedule userSchedule)? removeSchedule,
    TResult Function(
            UserSchedule oldUserSchedule, UserSchedule newUserSchedule)?
        updateSchedule,
    TResult Function(List<User> users, DateTime start, DateTime end)?
        generateSchedule,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InitScheduler value) initScheduler,
    required TResult Function(_AddSchedule value) addSchedule,
    required TResult Function(_RemoveSchedule value) removeSchedule,
    required TResult Function(_UpdateSchedule value) updateSchedule,
    required TResult Function(_GenerateSchedule value) generateSchedule,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_InitScheduler value)? initScheduler,
    TResult? Function(_AddSchedule value)? addSchedule,
    TResult? Function(_RemoveSchedule value)? removeSchedule,
    TResult? Function(_UpdateSchedule value)? updateSchedule,
    TResult? Function(_GenerateSchedule value)? generateSchedule,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InitScheduler value)? initScheduler,
    TResult Function(_AddSchedule value)? addSchedule,
    TResult Function(_RemoveSchedule value)? removeSchedule,
    TResult Function(_UpdateSchedule value)? updateSchedule,
    TResult Function(_GenerateSchedule value)? generateSchedule,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SchedulerEventCopyWith<$Res> {
  factory $SchedulerEventCopyWith(
          SchedulerEvent value, $Res Function(SchedulerEvent) then) =
      _$SchedulerEventCopyWithImpl<$Res, SchedulerEvent>;
}

/// @nodoc
class _$SchedulerEventCopyWithImpl<$Res, $Val extends SchedulerEvent>
    implements $SchedulerEventCopyWith<$Res> {
  _$SchedulerEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of SchedulerEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$InitSchedulerImplCopyWith<$Res> {
  factory _$$InitSchedulerImplCopyWith(
          _$InitSchedulerImpl value, $Res Function(_$InitSchedulerImpl) then) =
      __$$InitSchedulerImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$InitSchedulerImplCopyWithImpl<$Res>
    extends _$SchedulerEventCopyWithImpl<$Res, _$InitSchedulerImpl>
    implements _$$InitSchedulerImplCopyWith<$Res> {
  __$$InitSchedulerImplCopyWithImpl(
      _$InitSchedulerImpl _value, $Res Function(_$InitSchedulerImpl) _then)
      : super(_value, _then);

  /// Create a copy of SchedulerEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$InitSchedulerImpl implements _InitScheduler {
  const _$InitSchedulerImpl();

  @override
  String toString() {
    return 'SchedulerEvent.initScheduler()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$InitSchedulerImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initScheduler,
    required TResult Function(UserSchedule userSchedule) addSchedule,
    required TResult Function(UserSchedule userSchedule) removeSchedule,
    required TResult Function(
            UserSchedule oldUserSchedule, UserSchedule newUserSchedule)
        updateSchedule,
    required TResult Function(List<User> users, DateTime start, DateTime end)
        generateSchedule,
  }) {
    return initScheduler();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initScheduler,
    TResult? Function(UserSchedule userSchedule)? addSchedule,
    TResult? Function(UserSchedule userSchedule)? removeSchedule,
    TResult? Function(
            UserSchedule oldUserSchedule, UserSchedule newUserSchedule)?
        updateSchedule,
    TResult? Function(List<User> users, DateTime start, DateTime end)?
        generateSchedule,
  }) {
    return initScheduler?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initScheduler,
    TResult Function(UserSchedule userSchedule)? addSchedule,
    TResult Function(UserSchedule userSchedule)? removeSchedule,
    TResult Function(
            UserSchedule oldUserSchedule, UserSchedule newUserSchedule)?
        updateSchedule,
    TResult Function(List<User> users, DateTime start, DateTime end)?
        generateSchedule,
    required TResult orElse(),
  }) {
    if (initScheduler != null) {
      return initScheduler();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InitScheduler value) initScheduler,
    required TResult Function(_AddSchedule value) addSchedule,
    required TResult Function(_RemoveSchedule value) removeSchedule,
    required TResult Function(_UpdateSchedule value) updateSchedule,
    required TResult Function(_GenerateSchedule value) generateSchedule,
  }) {
    return initScheduler(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_InitScheduler value)? initScheduler,
    TResult? Function(_AddSchedule value)? addSchedule,
    TResult? Function(_RemoveSchedule value)? removeSchedule,
    TResult? Function(_UpdateSchedule value)? updateSchedule,
    TResult? Function(_GenerateSchedule value)? generateSchedule,
  }) {
    return initScheduler?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InitScheduler value)? initScheduler,
    TResult Function(_AddSchedule value)? addSchedule,
    TResult Function(_RemoveSchedule value)? removeSchedule,
    TResult Function(_UpdateSchedule value)? updateSchedule,
    TResult Function(_GenerateSchedule value)? generateSchedule,
    required TResult orElse(),
  }) {
    if (initScheduler != null) {
      return initScheduler(this);
    }
    return orElse();
  }
}

abstract class _InitScheduler implements SchedulerEvent {
  const factory _InitScheduler() = _$InitSchedulerImpl;
}

/// @nodoc
abstract class _$$AddScheduleImplCopyWith<$Res> {
  factory _$$AddScheduleImplCopyWith(
          _$AddScheduleImpl value, $Res Function(_$AddScheduleImpl) then) =
      __$$AddScheduleImplCopyWithImpl<$Res>;
  @useResult
  $Res call({UserSchedule userSchedule});

  $UserScheduleCopyWith<$Res> get userSchedule;
}

/// @nodoc
class __$$AddScheduleImplCopyWithImpl<$Res>
    extends _$SchedulerEventCopyWithImpl<$Res, _$AddScheduleImpl>
    implements _$$AddScheduleImplCopyWith<$Res> {
  __$$AddScheduleImplCopyWithImpl(
      _$AddScheduleImpl _value, $Res Function(_$AddScheduleImpl) _then)
      : super(_value, _then);

  /// Create a copy of SchedulerEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? userSchedule = null,
  }) {
    return _then(_$AddScheduleImpl(
      null == userSchedule
          ? _value.userSchedule
          : userSchedule // ignore: cast_nullable_to_non_nullable
              as UserSchedule,
    ));
  }

  /// Create a copy of SchedulerEvent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $UserScheduleCopyWith<$Res> get userSchedule {
    return $UserScheduleCopyWith<$Res>(_value.userSchedule, (value) {
      return _then(_value.copyWith(userSchedule: value));
    });
  }
}

/// @nodoc

class _$AddScheduleImpl implements _AddSchedule {
  const _$AddScheduleImpl(this.userSchedule);

  @override
  final UserSchedule userSchedule;

  @override
  String toString() {
    return 'SchedulerEvent.addSchedule(userSchedule: $userSchedule)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AddScheduleImpl &&
            (identical(other.userSchedule, userSchedule) ||
                other.userSchedule == userSchedule));
  }

  @override
  int get hashCode => Object.hash(runtimeType, userSchedule);

  /// Create a copy of SchedulerEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$AddScheduleImplCopyWith<_$AddScheduleImpl> get copyWith =>
      __$$AddScheduleImplCopyWithImpl<_$AddScheduleImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initScheduler,
    required TResult Function(UserSchedule userSchedule) addSchedule,
    required TResult Function(UserSchedule userSchedule) removeSchedule,
    required TResult Function(
            UserSchedule oldUserSchedule, UserSchedule newUserSchedule)
        updateSchedule,
    required TResult Function(List<User> users, DateTime start, DateTime end)
        generateSchedule,
  }) {
    return addSchedule(userSchedule);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initScheduler,
    TResult? Function(UserSchedule userSchedule)? addSchedule,
    TResult? Function(UserSchedule userSchedule)? removeSchedule,
    TResult? Function(
            UserSchedule oldUserSchedule, UserSchedule newUserSchedule)?
        updateSchedule,
    TResult? Function(List<User> users, DateTime start, DateTime end)?
        generateSchedule,
  }) {
    return addSchedule?.call(userSchedule);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initScheduler,
    TResult Function(UserSchedule userSchedule)? addSchedule,
    TResult Function(UserSchedule userSchedule)? removeSchedule,
    TResult Function(
            UserSchedule oldUserSchedule, UserSchedule newUserSchedule)?
        updateSchedule,
    TResult Function(List<User> users, DateTime start, DateTime end)?
        generateSchedule,
    required TResult orElse(),
  }) {
    if (addSchedule != null) {
      return addSchedule(userSchedule);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InitScheduler value) initScheduler,
    required TResult Function(_AddSchedule value) addSchedule,
    required TResult Function(_RemoveSchedule value) removeSchedule,
    required TResult Function(_UpdateSchedule value) updateSchedule,
    required TResult Function(_GenerateSchedule value) generateSchedule,
  }) {
    return addSchedule(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_InitScheduler value)? initScheduler,
    TResult? Function(_AddSchedule value)? addSchedule,
    TResult? Function(_RemoveSchedule value)? removeSchedule,
    TResult? Function(_UpdateSchedule value)? updateSchedule,
    TResult? Function(_GenerateSchedule value)? generateSchedule,
  }) {
    return addSchedule?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InitScheduler value)? initScheduler,
    TResult Function(_AddSchedule value)? addSchedule,
    TResult Function(_RemoveSchedule value)? removeSchedule,
    TResult Function(_UpdateSchedule value)? updateSchedule,
    TResult Function(_GenerateSchedule value)? generateSchedule,
    required TResult orElse(),
  }) {
    if (addSchedule != null) {
      return addSchedule(this);
    }
    return orElse();
  }
}

abstract class _AddSchedule implements SchedulerEvent {
  const factory _AddSchedule(final UserSchedule userSchedule) =
      _$AddScheduleImpl;

  UserSchedule get userSchedule;

  /// Create a copy of SchedulerEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$AddScheduleImplCopyWith<_$AddScheduleImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$RemoveScheduleImplCopyWith<$Res> {
  factory _$$RemoveScheduleImplCopyWith(_$RemoveScheduleImpl value,
          $Res Function(_$RemoveScheduleImpl) then) =
      __$$RemoveScheduleImplCopyWithImpl<$Res>;
  @useResult
  $Res call({UserSchedule userSchedule});

  $UserScheduleCopyWith<$Res> get userSchedule;
}

/// @nodoc
class __$$RemoveScheduleImplCopyWithImpl<$Res>
    extends _$SchedulerEventCopyWithImpl<$Res, _$RemoveScheduleImpl>
    implements _$$RemoveScheduleImplCopyWith<$Res> {
  __$$RemoveScheduleImplCopyWithImpl(
      _$RemoveScheduleImpl _value, $Res Function(_$RemoveScheduleImpl) _then)
      : super(_value, _then);

  /// Create a copy of SchedulerEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? userSchedule = null,
  }) {
    return _then(_$RemoveScheduleImpl(
      null == userSchedule
          ? _value.userSchedule
          : userSchedule // ignore: cast_nullable_to_non_nullable
              as UserSchedule,
    ));
  }

  /// Create a copy of SchedulerEvent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $UserScheduleCopyWith<$Res> get userSchedule {
    return $UserScheduleCopyWith<$Res>(_value.userSchedule, (value) {
      return _then(_value.copyWith(userSchedule: value));
    });
  }
}

/// @nodoc

class _$RemoveScheduleImpl implements _RemoveSchedule {
  const _$RemoveScheduleImpl(this.userSchedule);

  @override
  final UserSchedule userSchedule;

  @override
  String toString() {
    return 'SchedulerEvent.removeSchedule(userSchedule: $userSchedule)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RemoveScheduleImpl &&
            (identical(other.userSchedule, userSchedule) ||
                other.userSchedule == userSchedule));
  }

  @override
  int get hashCode => Object.hash(runtimeType, userSchedule);

  /// Create a copy of SchedulerEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$RemoveScheduleImplCopyWith<_$RemoveScheduleImpl> get copyWith =>
      __$$RemoveScheduleImplCopyWithImpl<_$RemoveScheduleImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initScheduler,
    required TResult Function(UserSchedule userSchedule) addSchedule,
    required TResult Function(UserSchedule userSchedule) removeSchedule,
    required TResult Function(
            UserSchedule oldUserSchedule, UserSchedule newUserSchedule)
        updateSchedule,
    required TResult Function(List<User> users, DateTime start, DateTime end)
        generateSchedule,
  }) {
    return removeSchedule(userSchedule);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initScheduler,
    TResult? Function(UserSchedule userSchedule)? addSchedule,
    TResult? Function(UserSchedule userSchedule)? removeSchedule,
    TResult? Function(
            UserSchedule oldUserSchedule, UserSchedule newUserSchedule)?
        updateSchedule,
    TResult? Function(List<User> users, DateTime start, DateTime end)?
        generateSchedule,
  }) {
    return removeSchedule?.call(userSchedule);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initScheduler,
    TResult Function(UserSchedule userSchedule)? addSchedule,
    TResult Function(UserSchedule userSchedule)? removeSchedule,
    TResult Function(
            UserSchedule oldUserSchedule, UserSchedule newUserSchedule)?
        updateSchedule,
    TResult Function(List<User> users, DateTime start, DateTime end)?
        generateSchedule,
    required TResult orElse(),
  }) {
    if (removeSchedule != null) {
      return removeSchedule(userSchedule);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InitScheduler value) initScheduler,
    required TResult Function(_AddSchedule value) addSchedule,
    required TResult Function(_RemoveSchedule value) removeSchedule,
    required TResult Function(_UpdateSchedule value) updateSchedule,
    required TResult Function(_GenerateSchedule value) generateSchedule,
  }) {
    return removeSchedule(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_InitScheduler value)? initScheduler,
    TResult? Function(_AddSchedule value)? addSchedule,
    TResult? Function(_RemoveSchedule value)? removeSchedule,
    TResult? Function(_UpdateSchedule value)? updateSchedule,
    TResult? Function(_GenerateSchedule value)? generateSchedule,
  }) {
    return removeSchedule?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InitScheduler value)? initScheduler,
    TResult Function(_AddSchedule value)? addSchedule,
    TResult Function(_RemoveSchedule value)? removeSchedule,
    TResult Function(_UpdateSchedule value)? updateSchedule,
    TResult Function(_GenerateSchedule value)? generateSchedule,
    required TResult orElse(),
  }) {
    if (removeSchedule != null) {
      return removeSchedule(this);
    }
    return orElse();
  }
}

abstract class _RemoveSchedule implements SchedulerEvent {
  const factory _RemoveSchedule(final UserSchedule userSchedule) =
      _$RemoveScheduleImpl;

  UserSchedule get userSchedule;

  /// Create a copy of SchedulerEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$RemoveScheduleImplCopyWith<_$RemoveScheduleImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UpdateScheduleImplCopyWith<$Res> {
  factory _$$UpdateScheduleImplCopyWith(_$UpdateScheduleImpl value,
          $Res Function(_$UpdateScheduleImpl) then) =
      __$$UpdateScheduleImplCopyWithImpl<$Res>;
  @useResult
  $Res call({UserSchedule oldUserSchedule, UserSchedule newUserSchedule});

  $UserScheduleCopyWith<$Res> get oldUserSchedule;
  $UserScheduleCopyWith<$Res> get newUserSchedule;
}

/// @nodoc
class __$$UpdateScheduleImplCopyWithImpl<$Res>
    extends _$SchedulerEventCopyWithImpl<$Res, _$UpdateScheduleImpl>
    implements _$$UpdateScheduleImplCopyWith<$Res> {
  __$$UpdateScheduleImplCopyWithImpl(
      _$UpdateScheduleImpl _value, $Res Function(_$UpdateScheduleImpl) _then)
      : super(_value, _then);

  /// Create a copy of SchedulerEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? oldUserSchedule = null,
    Object? newUserSchedule = null,
  }) {
    return _then(_$UpdateScheduleImpl(
      oldUserSchedule: null == oldUserSchedule
          ? _value.oldUserSchedule
          : oldUserSchedule // ignore: cast_nullable_to_non_nullable
              as UserSchedule,
      newUserSchedule: null == newUserSchedule
          ? _value.newUserSchedule
          : newUserSchedule // ignore: cast_nullable_to_non_nullable
              as UserSchedule,
    ));
  }

  /// Create a copy of SchedulerEvent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $UserScheduleCopyWith<$Res> get oldUserSchedule {
    return $UserScheduleCopyWith<$Res>(_value.oldUserSchedule, (value) {
      return _then(_value.copyWith(oldUserSchedule: value));
    });
  }

  /// Create a copy of SchedulerEvent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $UserScheduleCopyWith<$Res> get newUserSchedule {
    return $UserScheduleCopyWith<$Res>(_value.newUserSchedule, (value) {
      return _then(_value.copyWith(newUserSchedule: value));
    });
  }
}

/// @nodoc

class _$UpdateScheduleImpl implements _UpdateSchedule {
  const _$UpdateScheduleImpl(
      {required this.oldUserSchedule, required this.newUserSchedule});

  @override
  final UserSchedule oldUserSchedule;
  @override
  final UserSchedule newUserSchedule;

  @override
  String toString() {
    return 'SchedulerEvent.updateSchedule(oldUserSchedule: $oldUserSchedule, newUserSchedule: $newUserSchedule)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UpdateScheduleImpl &&
            (identical(other.oldUserSchedule, oldUserSchedule) ||
                other.oldUserSchedule == oldUserSchedule) &&
            (identical(other.newUserSchedule, newUserSchedule) ||
                other.newUserSchedule == newUserSchedule));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, oldUserSchedule, newUserSchedule);

  /// Create a copy of SchedulerEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$UpdateScheduleImplCopyWith<_$UpdateScheduleImpl> get copyWith =>
      __$$UpdateScheduleImplCopyWithImpl<_$UpdateScheduleImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initScheduler,
    required TResult Function(UserSchedule userSchedule) addSchedule,
    required TResult Function(UserSchedule userSchedule) removeSchedule,
    required TResult Function(
            UserSchedule oldUserSchedule, UserSchedule newUserSchedule)
        updateSchedule,
    required TResult Function(List<User> users, DateTime start, DateTime end)
        generateSchedule,
  }) {
    return updateSchedule(oldUserSchedule, newUserSchedule);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initScheduler,
    TResult? Function(UserSchedule userSchedule)? addSchedule,
    TResult? Function(UserSchedule userSchedule)? removeSchedule,
    TResult? Function(
            UserSchedule oldUserSchedule, UserSchedule newUserSchedule)?
        updateSchedule,
    TResult? Function(List<User> users, DateTime start, DateTime end)?
        generateSchedule,
  }) {
    return updateSchedule?.call(oldUserSchedule, newUserSchedule);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initScheduler,
    TResult Function(UserSchedule userSchedule)? addSchedule,
    TResult Function(UserSchedule userSchedule)? removeSchedule,
    TResult Function(
            UserSchedule oldUserSchedule, UserSchedule newUserSchedule)?
        updateSchedule,
    TResult Function(List<User> users, DateTime start, DateTime end)?
        generateSchedule,
    required TResult orElse(),
  }) {
    if (updateSchedule != null) {
      return updateSchedule(oldUserSchedule, newUserSchedule);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InitScheduler value) initScheduler,
    required TResult Function(_AddSchedule value) addSchedule,
    required TResult Function(_RemoveSchedule value) removeSchedule,
    required TResult Function(_UpdateSchedule value) updateSchedule,
    required TResult Function(_GenerateSchedule value) generateSchedule,
  }) {
    return updateSchedule(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_InitScheduler value)? initScheduler,
    TResult? Function(_AddSchedule value)? addSchedule,
    TResult? Function(_RemoveSchedule value)? removeSchedule,
    TResult? Function(_UpdateSchedule value)? updateSchedule,
    TResult? Function(_GenerateSchedule value)? generateSchedule,
  }) {
    return updateSchedule?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InitScheduler value)? initScheduler,
    TResult Function(_AddSchedule value)? addSchedule,
    TResult Function(_RemoveSchedule value)? removeSchedule,
    TResult Function(_UpdateSchedule value)? updateSchedule,
    TResult Function(_GenerateSchedule value)? generateSchedule,
    required TResult orElse(),
  }) {
    if (updateSchedule != null) {
      return updateSchedule(this);
    }
    return orElse();
  }
}

abstract class _UpdateSchedule implements SchedulerEvent {
  const factory _UpdateSchedule(
      {required final UserSchedule oldUserSchedule,
      required final UserSchedule newUserSchedule}) = _$UpdateScheduleImpl;

  UserSchedule get oldUserSchedule;
  UserSchedule get newUserSchedule;

  /// Create a copy of SchedulerEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$UpdateScheduleImplCopyWith<_$UpdateScheduleImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$GenerateScheduleImplCopyWith<$Res> {
  factory _$$GenerateScheduleImplCopyWith(_$GenerateScheduleImpl value,
          $Res Function(_$GenerateScheduleImpl) then) =
      __$$GenerateScheduleImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<User> users, DateTime start, DateTime end});
}

/// @nodoc
class __$$GenerateScheduleImplCopyWithImpl<$Res>
    extends _$SchedulerEventCopyWithImpl<$Res, _$GenerateScheduleImpl>
    implements _$$GenerateScheduleImplCopyWith<$Res> {
  __$$GenerateScheduleImplCopyWithImpl(_$GenerateScheduleImpl _value,
      $Res Function(_$GenerateScheduleImpl) _then)
      : super(_value, _then);

  /// Create a copy of SchedulerEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? users = null,
    Object? start = null,
    Object? end = null,
  }) {
    return _then(_$GenerateScheduleImpl(
      users: null == users
          ? _value._users
          : users // ignore: cast_nullable_to_non_nullable
              as List<User>,
      start: null == start
          ? _value.start
          : start // ignore: cast_nullable_to_non_nullable
              as DateTime,
      end: null == end
          ? _value.end
          : end // ignore: cast_nullable_to_non_nullable
              as DateTime,
    ));
  }
}

/// @nodoc

class _$GenerateScheduleImpl implements _GenerateSchedule {
  const _$GenerateScheduleImpl(
      {required final List<User> users, required this.start, required this.end})
      : _users = users;

  final List<User> _users;
  @override
  List<User> get users {
    if (_users is EqualUnmodifiableListView) return _users;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_users);
  }

  @override
  final DateTime start;
  @override
  final DateTime end;

  @override
  String toString() {
    return 'SchedulerEvent.generateSchedule(users: $users, start: $start, end: $end)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$GenerateScheduleImpl &&
            const DeepCollectionEquality().equals(other._users, _users) &&
            (identical(other.start, start) || other.start == start) &&
            (identical(other.end, end) || other.end == end));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(_users), start, end);

  /// Create a copy of SchedulerEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$GenerateScheduleImplCopyWith<_$GenerateScheduleImpl> get copyWith =>
      __$$GenerateScheduleImplCopyWithImpl<_$GenerateScheduleImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initScheduler,
    required TResult Function(UserSchedule userSchedule) addSchedule,
    required TResult Function(UserSchedule userSchedule) removeSchedule,
    required TResult Function(
            UserSchedule oldUserSchedule, UserSchedule newUserSchedule)
        updateSchedule,
    required TResult Function(List<User> users, DateTime start, DateTime end)
        generateSchedule,
  }) {
    return generateSchedule(users, start, end);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initScheduler,
    TResult? Function(UserSchedule userSchedule)? addSchedule,
    TResult? Function(UserSchedule userSchedule)? removeSchedule,
    TResult? Function(
            UserSchedule oldUserSchedule, UserSchedule newUserSchedule)?
        updateSchedule,
    TResult? Function(List<User> users, DateTime start, DateTime end)?
        generateSchedule,
  }) {
    return generateSchedule?.call(users, start, end);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initScheduler,
    TResult Function(UserSchedule userSchedule)? addSchedule,
    TResult Function(UserSchedule userSchedule)? removeSchedule,
    TResult Function(
            UserSchedule oldUserSchedule, UserSchedule newUserSchedule)?
        updateSchedule,
    TResult Function(List<User> users, DateTime start, DateTime end)?
        generateSchedule,
    required TResult orElse(),
  }) {
    if (generateSchedule != null) {
      return generateSchedule(users, start, end);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InitScheduler value) initScheduler,
    required TResult Function(_AddSchedule value) addSchedule,
    required TResult Function(_RemoveSchedule value) removeSchedule,
    required TResult Function(_UpdateSchedule value) updateSchedule,
    required TResult Function(_GenerateSchedule value) generateSchedule,
  }) {
    return generateSchedule(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_InitScheduler value)? initScheduler,
    TResult? Function(_AddSchedule value)? addSchedule,
    TResult? Function(_RemoveSchedule value)? removeSchedule,
    TResult? Function(_UpdateSchedule value)? updateSchedule,
    TResult? Function(_GenerateSchedule value)? generateSchedule,
  }) {
    return generateSchedule?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InitScheduler value)? initScheduler,
    TResult Function(_AddSchedule value)? addSchedule,
    TResult Function(_RemoveSchedule value)? removeSchedule,
    TResult Function(_UpdateSchedule value)? updateSchedule,
    TResult Function(_GenerateSchedule value)? generateSchedule,
    required TResult orElse(),
  }) {
    if (generateSchedule != null) {
      return generateSchedule(this);
    }
    return orElse();
  }
}

abstract class _GenerateSchedule implements SchedulerEvent {
  const factory _GenerateSchedule(
      {required final List<User> users,
      required final DateTime start,
      required final DateTime end}) = _$GenerateScheduleImpl;

  List<User> get users;
  DateTime get start;
  DateTime get end;

  /// Create a copy of SchedulerEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$GenerateScheduleImplCopyWith<_$GenerateScheduleImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$SchedulerState {
  List<UserSchedule> get userSchedules => throw _privateConstructorUsedError;
  List<User> get users => throw _privateConstructorUsedError;
  int get userId => throw _privateConstructorUsedError;

  /// Create a copy of SchedulerState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $SchedulerStateCopyWith<SchedulerState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SchedulerStateCopyWith<$Res> {
  factory $SchedulerStateCopyWith(
          SchedulerState value, $Res Function(SchedulerState) then) =
      _$SchedulerStateCopyWithImpl<$Res, SchedulerState>;
  @useResult
  $Res call({List<UserSchedule> userSchedules, List<User> users, int userId});
}

/// @nodoc
class _$SchedulerStateCopyWithImpl<$Res, $Val extends SchedulerState>
    implements $SchedulerStateCopyWith<$Res> {
  _$SchedulerStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of SchedulerState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? userSchedules = null,
    Object? users = null,
    Object? userId = null,
  }) {
    return _then(_value.copyWith(
      userSchedules: null == userSchedules
          ? _value.userSchedules
          : userSchedules // ignore: cast_nullable_to_non_nullable
              as List<UserSchedule>,
      users: null == users
          ? _value.users
          : users // ignore: cast_nullable_to_non_nullable
              as List<User>,
      userId: null == userId
          ? _value.userId
          : userId // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$SchedulerStateImplCopyWith<$Res>
    implements $SchedulerStateCopyWith<$Res> {
  factory _$$SchedulerStateImplCopyWith(_$SchedulerStateImpl value,
          $Res Function(_$SchedulerStateImpl) then) =
      __$$SchedulerStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({List<UserSchedule> userSchedules, List<User> users, int userId});
}

/// @nodoc
class __$$SchedulerStateImplCopyWithImpl<$Res>
    extends _$SchedulerStateCopyWithImpl<$Res, _$SchedulerStateImpl>
    implements _$$SchedulerStateImplCopyWith<$Res> {
  __$$SchedulerStateImplCopyWithImpl(
      _$SchedulerStateImpl _value, $Res Function(_$SchedulerStateImpl) _then)
      : super(_value, _then);

  /// Create a copy of SchedulerState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? userSchedules = null,
    Object? users = null,
    Object? userId = null,
  }) {
    return _then(_$SchedulerStateImpl(
      userSchedules: null == userSchedules
          ? _value._userSchedules
          : userSchedules // ignore: cast_nullable_to_non_nullable
              as List<UserSchedule>,
      users: null == users
          ? _value._users
          : users // ignore: cast_nullable_to_non_nullable
              as List<User>,
      userId: null == userId
          ? _value.userId
          : userId // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$SchedulerStateImpl implements _SchedulerState {
  const _$SchedulerStateImpl(
      {required final List<UserSchedule> userSchedules,
      required final List<User> users,
      required this.userId})
      : _userSchedules = userSchedules,
        _users = users;

  final List<UserSchedule> _userSchedules;
  @override
  List<UserSchedule> get userSchedules {
    if (_userSchedules is EqualUnmodifiableListView) return _userSchedules;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_userSchedules);
  }

  final List<User> _users;
  @override
  List<User> get users {
    if (_users is EqualUnmodifiableListView) return _users;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_users);
  }

  @override
  final int userId;

  @override
  String toString() {
    return 'SchedulerState(userSchedules: $userSchedules, users: $users, userId: $userId)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SchedulerStateImpl &&
            const DeepCollectionEquality()
                .equals(other._userSchedules, _userSchedules) &&
            const DeepCollectionEquality().equals(other._users, _users) &&
            (identical(other.userId, userId) || other.userId == userId));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_userSchedules),
      const DeepCollectionEquality().hash(_users),
      userId);

  /// Create a copy of SchedulerState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$SchedulerStateImplCopyWith<_$SchedulerStateImpl> get copyWith =>
      __$$SchedulerStateImplCopyWithImpl<_$SchedulerStateImpl>(
          this, _$identity);
}

abstract class _SchedulerState implements SchedulerState {
  const factory _SchedulerState(
      {required final List<UserSchedule> userSchedules,
      required final List<User> users,
      required final int userId}) = _$SchedulerStateImpl;

  @override
  List<UserSchedule> get userSchedules;
  @override
  List<User> get users;
  @override
  int get userId;

  /// Create a copy of SchedulerState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$SchedulerStateImplCopyWith<_$SchedulerStateImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
